<h1>Data Entry Forms</h1>

<div class="data-entry-section">
    <h2>Three.js Drum Wheel Demo</h2>
    <p>Testing the Three.js drum wheel implementation for year selection:</p>
    
    <div class="form-group">
        <label for="year-selector">Select Year:</label>
        <div id="threejs-drum-container" style="margin: 20px 0;"></div>
        <div class="selected-value">
            Selected: <span id="selected-year">2024</span>
        </div>
    </div>
</div>

<div class="data-entry-section">
    <h2>Other Form Elements</h2>
    <p>Additional data entry components will be added here.</p>
</div>

<!-- Load Three.js from CDN for this demo -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
// Three.js Drum Wheel Implementation (inline for now)
class ThreeDrumWheelEngine {
    constructor(container, options = {}) {
        this.container = container;
        this.options = {
            items: options.items || [],
            selectedIndex: options.selectedIndex || 0,
            onChange: options.onChange || (() => {}),
            ...options
        };

        this.currentRotation = 0;
        this.targetRotation = 0;
        this.isDragging = false;
        this.previousMouseY = 0;
        this.velocity = 0;
        this.selectedIndex = this.options.selectedIndex;

        this.init();
    }

    init() {
        // Setup container
        this.container.style.width = '300px';
        this.container.style.height = '350px';
        this.container.style.position = 'relative';
        this.container.style.overflow = 'hidden';
        this.container.style.cursor = 'grab';
        this.container.style.borderRadius = '12px';
        this.container.style.margin = '0 auto';

        // Create Three.js scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0xf0f0f0);

        // Setup camera
        const aspect = 300 / 350;
        this.camera = new THREE.PerspectiveCamera(40, aspect, 0.1, 1000);
        this.camera.position.z = 200;

        // Setup renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(300, 350);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.container.appendChild(this.renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(0, 1, 1);
        this.scene.add(directionalLight);

        // Create drum
        this.createDrum();

        // Add selection indicator
        this.createSelectionIndicator();

        // Setup interactions
        this.setupInteractions();

        // Start animation
        this.animate();
    }

    createDrum() {
        const itemCount = this.options.items.length;
        const radius = 80;
        const height = 300;

        // Create texture with years
        const canvas = document.createElement('canvas');
        canvas.width = 2048;
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');

        // Background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw items
        ctx.fillStyle = '#333333';
        ctx.font = 'bold 64px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        this.options.items.forEach((item, index) => {
            const x = ((index + 0.5) / itemCount) * canvas.width;
            const y = canvas.height / 2;
            ctx.fillText(String(item), x, y);
        });

        // Create texture
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;

        // Create cylinder geometry
        const geometry = new THREE.CylinderGeometry(radius, radius, height, 32, 1, true);
        
        // Rotate geometry to have seam at back
        geometry.rotateY(Math.PI);

        // Create material
        const material = new THREE.MeshPhongMaterial({
            map: texture,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.9
        });

        // Create mesh
        this.drum = new THREE.Mesh(geometry, material);
        this.scene.add(this.drum);

        // Calculate angle per item
        this.anglePerItem = (Math.PI * 2) / itemCount;
    }

    createSelectionIndicator() {
        // Create selection highlight
        const geometry = new THREE.BoxGeometry(120, 50, 1);
        const material = new THREE.MeshBasicMaterial({
            color: 0x007AFF,
            transparent: true,
            opacity: 0.3
        });
        this.selectionBox = new THREE.Mesh(geometry, material);
        this.selectionBox.position.z = 81;
        this.scene.add(this.selectionBox);
    }

    setupInteractions() {
        const canvas = this.renderer.domElement;

        // Mouse events
        canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
        canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
        canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        canvas.addEventListener('mouseleave', this.onMouseUp.bind(this));

        // Touch events
        canvas.addEventListener('touchstart', this.onTouchStart.bind(this));
        canvas.addEventListener('touchmove', this.onTouchMove.bind(this));
        canvas.addEventListener('touchend', this.onTouchEnd.bind(this));

        // Wheel event
        canvas.addEventListener('wheel', this.onWheel.bind(this));
    }

    onMouseDown(e) {
        this.isDragging = true;
        this.previousMouseY = e.clientY;
        this.velocity = 0;
        this.container.style.cursor = 'grabbing';
    }

    onMouseMove(e) {
        if (!this.isDragging) return;

        const deltaY = e.clientY - this.previousMouseY;
        this.velocity = deltaY * 0.01;
        this.targetRotation += this.velocity;
        this.previousMouseY = e.clientY;
    }

    onMouseUp() {
        this.isDragging = false;
        this.container.style.cursor = 'grab';
        this.applyMomentum();
    }

    onTouchStart(e) {
        if (e.touches.length === 1) {
            this.isDragging = true;
            this.previousMouseY = e.touches[0].clientY;
            this.velocity = 0;
        }
    }

    onTouchMove(e) {
        if (!this.isDragging || e.touches.length !== 1) return;
        e.preventDefault();

        const deltaY = e.touches[0].clientY - this.previousMouseY;
        this.velocity = deltaY * 0.01;
        this.targetRotation += this.velocity;
        this.previousMouseY = e.touches[0].clientY;
    }

    onTouchEnd() {
        this.isDragging = false;
        this.applyMomentum();
    }

    onWheel(e) {
        e.preventDefault();
        this.velocity = -e.deltaY * 0.001;
        this.targetRotation += this.velocity * 10;
        this.snapToItem();
    }

    applyMomentum() {
        const deceleration = 0.95;
        const minVelocity = 0.001;

        const momentumAnimation = () => {
            if (Math.abs(this.velocity) > minVelocity) {
                this.targetRotation += this.velocity;
                this.velocity *= deceleration;
                requestAnimationFrame(momentumAnimation);
            } else {
                this.snapToItem();
            }
        };

        momentumAnimation();
    }

    snapToItem() {
        // Calculate nearest item
        const currentItem = Math.round(this.targetRotation / this.anglePerItem);
        this.targetRotation = currentItem * this.anglePerItem;

        // Calculate selected index
        const itemCount = this.options.items.length;
        this.selectedIndex = (((-currentItem % itemCount) + itemCount) % itemCount);

        // Trigger onChange
        if (this.options.onChange) {
            this.options.onChange(this.options.items[this.selectedIndex], this.selectedIndex);
        }
    }

    animate() {
        requestAnimationFrame(() => this.animate());

        // Smooth rotation
        this.currentRotation += (this.targetRotation - this.currentRotation) * 0.1;
        this.drum.rotation.y = this.currentRotation;

        // Update renderer
        this.renderer.render(this.scene, this.camera);
    }

    destroy() {
        // Clean up
        const canvas = this.renderer.domElement;
        canvas.removeEventListener('mousedown', this.onMouseDown);
        canvas.removeEventListener('mousemove', this.onMouseMove);
        canvas.removeEventListener('mouseup', this.onMouseUp);
        canvas.removeEventListener('touchstart', this.onTouchStart);
        canvas.removeEventListener('touchmove', this.onTouchMove);
        canvas.removeEventListener('touchend', this.onTouchEnd);
        canvas.removeEventListener('wheel', this.onWheel);

        this.renderer.dispose();
        this.container.removeChild(this.renderer.domElement);
    }
}

// Initialize the drum wheel when the page loads
// Using a timeout to ensure the container is properly rendered
setTimeout(() => {
    const container = document.getElementById('threejs-drum-container');
    if (container) {
        // Generate years array
        const years = [];
        for (let year = 2025; year >= 1926; year--) {
            years.push(year);
        }

        // Create Three.js drum wheel
        const drumWheel = new ThreeDrumWheelEngine(container, {
            items: years,
            selectedIndex: 1, // Start at 2024
            onChange: (value, index) => {
                document.getElementById('selected-year').textContent = value;
                console.log('[Three.js Drum] Selected:', value, 'Index:', index);
            }
        });
    }
}, 100);
</script>

<style>
.data-entry-section {
    background: white;
    border-radius: 12px;
    padding: 30px;
    margin-bottom: 20px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.data-entry-section h2 {
    margin-top: 0;
    margin-bottom: 15px;
    color: #1d1d1f;
}

.form-group {
    margin: 20px 0;
}

.form-group label {
    display: block;
    margin-bottom: 10px;
    font-weight: 600;
    color: #1d1d1f;
}

.selected-value {
    text-align: center;
    margin-top: 20px;
    font-size: 18px;
}

.selected-value span {
    font-weight: 600;
    color: #007AFF;
}
</style>
